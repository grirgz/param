title:: Param Cookbook
summary:: Tricks with GUI and controllers
categories:: GUI
related:: Classes/Param

section::Automatic GUI Generation


code::
(
SynthDef(\saw_help, { arg out=0, amp=0.1, gate=1, pan=0, spread=0.8, freq=200,  doneAction=2;
	var sig, sig1, sig2, sig3;
	sig = LFSaw.ar(freq * [1.01,1,0.99]);
	sig = RLPF.ar(sig, \lpfr.kr(1.1) * freq, \rq.kr(0.5));
	sig = sig * EnvGen.ar(\adsr.kr(Env.adsr(0.01,0.1,0.8,0.1)),gate,doneAction:doneAction);
	sig = Splay.ar(sig, spread, amp, pan);
	Out.ar(out, sig);
}).add;
);

(
Pdef(\help, 
	Pbind(
		\instrument, \saw_help,
		\degree, Pseq([Prand([Pwhite(0,1.0,Pwhite(0,7,1)), Pwhite(0,12,Pwhite(0,70,1).asStream)]),Pseq((0..10),1)],inf),
		\dur, Pseq([Prand([Pwhite(0,1.0,Pwhite(0,70,1)), Pwhite(0,12,Pwhite(0,70,1))])],inf)/12,
		\amp, 0.1,
	)
).play;
);

Pdef(\help).edit; // use default pdef editor

WindowDef(\NdefEditor).front(Ndef(\help)); // since Ndef already have an editor, you can use the default one with WindowDef
::




section:: GUI tricks

subsection:: Get list of parameters of a SynthDef

Param quark adds a shortcut to get the SynthDef description given the name;

code::
(
SynthDef(\saw_help, { arg out=0, amp=0.1, gate=1, pan=0, spread=0.8, freq=200,  doneAction=2;
	var sig, sig1, sig2, sig3;
	sig = LFSaw.ar(freq * [1.01,1,0.99]);
	sig = RLPF.ar(sig, \lpfr.kr(1.1) * freq, \rq.kr(0.5));
	sig = sig * EnvGen.ar(\adsr.kr(Env.adsr(0.01,0.1,0.8,0.1)),gate,doneAction:doneAction);
	sig = Splay.ar(sig, spread, amp, pan);
	Out.ar(out, sig);
}).add;
)

SynthDesc(\saw_help); // just write Desc instead of Def
SynthDescLib.global.at(\saw_help); // the standard method

(
SynthDesc(\saw_help).controls.collect({ arg control;
	control.name.debug("name");
	control.defaultValue.debug("value");
});
)

// collect parameters as Param objects, then edit them
// you need to provide a target for the Params since you can't control the SynthDef itself
SynthDesc(\saw_help).asParamGroup(Pdef(\help)).edit; 
::




subsection:: Showing a meter for a bus in a GUI

Use link::Classes/SimpleServerMeterView::;

code::
SimpleServerMeterView(nil, 0,2);
::




subsection:: Showing a meter under a slider

Nothing specific to Param here, but I find it very nice to have the meter under the slider.
The trick is to use StackLayout in mode \stackAll and put a clear background to the slider so we can see the meter.


code::
Pdef(\help, Pbind()).play; // simple sound

// simple example when slider control main volume and meter listen to bus 0 (SC audio out)
(
WindowDef(\help, { arg def;
	StackLayout(
		Param(Server.default.volume, \volume).asSlider.orientation_(\vertical).background_(Color.clear),
		SimpleServerMeterView(nil, 0,2, 0),
	).mode_(\stackAll)
}).front
)
::



subsection:: Showing a frequency spectrum scope for a bus

Use link::Classes/FreqScopeView::

code::
(
Pdef(\help, Pbind(\out, BusDef(\mybus, \audio))).play; // play in a bus, you'll hear nothing

WindowDef(\scope_help, { arg def;
	var scope = FreqScopeView(nil, Rect(0,0,100,100))
					.freqMode_(1)
					.active_(true);
	scope.inBus = BusDef(\mybus, \audio);  // read it
	scope.onClose = {
		// scope have its own synth to kill when closing the GUI
		scope.kill;
	};
}).front;
)
::


subsection:: Integrate a plot inside a GUI

Unfortunately, Plotter is not compatible with Layout and should have a parent view and a fixed size. 

code::
WindowDef(\plotter, {
	var freqview = View.new.fixedSize_(300@300);
	var ampview = View.new.fixedSize_(300@300);
	var ampTable = Signal.hammingWindow(1024).cubed;
	var freqTable = Signal.newClear(1024).waveFill({ arg i; 0.5 ** i * 20000 }, 0, 10);

	Plotter.new(parent:freqview).value_(freqTable);
	Plotter.new(parent:ampview).value_(ampTable);
	VLayout(
		freqview,
		ampview,
	)
}).front;
::


subsection:: Make a GUI for envelopes and arrays parameters

The easiest way to write SynthDefs that take link::Classes/Array:: and link::Classes/Env:: as parameters is to use the link::Classes/NamedControl:: class.
If the spec is correctly retrieved by Param, it will automatically choose the correct GUI (link::Classes/MultiSliderView:: or link::Classes/FixedEnvelopeView::);

code::
(
SynthDef(\env_help, { arg out=0, amp=0.1, gate=1, pan=0, spread=0.8, freq=200,  doneAction=2;
	var sig;
	var lpenv;
	sig = LFSaw.ar(freq * \freqtab.kr(1!8));
	lpenv = EnvGen.kr(\lpenv.kr(Env.adsr(0.1,0.1,0.8,0.1)), gate, doneAction:0);
	sig = RLPF.ar(sig, ( \lpfr.kr(1.1) * lpenv + 1 ) * freq, \rq.kr(0.5));
	sig = sig * EnvGen.ar(\adsr.kr(Env.adsr(0.01,0.1,0.8,0.1)),gate,doneAction:doneAction);
	sig = Splay.ar(sig, spread, amp, pan);
	Out.ar(out, sig);
}, metadata:(specs:(
	lpenv: ParamEnvSpec.adsr, // there is no difference between array and env on the server, you should make it explicit
	adsr: ParamEnvSpec.adsr,
))).add;
);

Pdef(\help, Pbind(\instrument, \env_help));

(
WindowDef(\help, {
	VLayout (
		PlayerWrapper(Pdef(\help)).asView,

		// automatic creation from SynthDef spec
		Param(Pdef(\help), \freqtab).asView,
		Param(Pdef(\help), \lpenv).asView,

		// manually create the same multi slider and env view
		Param(Pdef(\help), \freqtab).asMultiSlider,
		Param(Pdef(\help), \lpenv).asEnvelopeView,
	)
}).front;
)
::





subsection:: Control individual segments of an envelope parameter

It's often easier to have a separate attack parameter than manipulate the Env directly.
Param let you target a specific segment of an envelope or array to easily assign a GUI or controller knob

code::
Param(Pdef(\help), \adsr -> \attack); // this point to the attack time value of the adsr Env
Param(Pdef(\help), \adsr -> \levels -> 1); // this point to the level of the second node of the envelope
::

See link::Classes/Param:: code::property:: argument of code::new:: method for the list



subsection:: Control Tempo


Param accept a clock as the target, it is easy to create a Param pointing to tempo:

code::
Param(TempoClock.default, \tempo, ControlSpec(1/2,2,\lin)).edit
::



subsection:: Control main volume

Param accept a volume as the target, so you can use where you want

code::
Param(Server.default.volume, \volume).edit; // default spec : \db.asSpec
::


subsection:: Control any object member instead of synth parameters

Param accept a wide range of targets, but sometime you want to control a
regular variable of an arbitrary object. 

For example if you want to point to the
quant of a Pdef, you can't write code::Param(Pdef(\help), \quant):: because it will do
code::Pdef(\help).get(\quant):: behind the scene. To tell param that you want to access
to code::Pdef(\bla).quant:: instead, you have to put the target inside a Message object.

Note::
Message class is not meant to be used this way normally, it is only used as a
flag for Param.
::

code::
Param(Message(Pdef(\mypdef)), \quant).edit; 
::

subsection:: Control global quant

Pdef have a default quant when none is set yet (link::Classes/Pdef#.defaultQuant::).
Use the generic object method pointer syntax (Message) to control the defaultQuant

code::
Param(Message(Pdef), \defaultQuant).edit; 
::



subsection:: Make a piano view

There is a class available in Param quark named link::Classes/MIDIKeyboardView:: which display a keyboard view.

code::
(

Pbindef(\help, Pbind()); // default sound

WindowDef(\pianokeyboard, { 
	var kb = MIDIKeyboardView.new;
	kb.mapPattern(Pdef(\help)); // special method to map a pattern to the GUI keyboard
	kb.asView;
}).front;
)

Pbindef(\help, \detune, Prand([0,14,50],inf)); // you can change the pattern while attached to keyboard since it's a Pdef or Pbindef
::

Here is what does mapPattern behind the scene. You can see you need to define keyDownAction, keyTrackAction and keyUpAction to make this Piano view work with anything you want.
Here the object SeqPlayerGroup is used to create a special player out of a pattern

code::
(
WindowDef(\pianokeyboard, { arg def, target;
	var kb = MIDIKeyboardView.new;
	if(target.notNil) {
		// SeqPlayerGroup is an object that take a pattern as input and provide an array of players
		// each player represent a note, and when playing it, you play instead an event of the provided pattern
		// the midinote of the player replace the \midinote of the event
		// to access to individual players in array, you use .elAt method
		var player = ProtoTemplateDef(\SeqPlayerGroup).new(target);
		
		kb.keyDownAction = { arg midinote, old;
			if(old.notNil) {
				player.elAt(old).stop;
			};
			player.elAt(midinote).play;
		};
		kb.keyTrackAction = { arg midinote, old;
			player.elAt(old).stop;
			player.elAt(midinote).play;
		};
		kb.keyUpAction = { arg midinote;
			player.elAt(midinote).stop;
		};
	};
	def.windowDo { arg win; // special method of WindowDef to manipulate the Window if available
		win.setInnerExtent(800,120); // set a default size to look nice at first try
	};
	kb.asView;
}).front(Pdef(\help)); // GUI is made generic by taking the pattern as argument
)
::

subsection:: Route audio and control with PopUpMenu

For a complete tutorial on BusDef and BufDef, see TODO

BusDef can be used to create and retrieve a bus. 

code::
(
SynthDef(\modulator, { arg out=0, gate=1, freq=1, modScale=1, modBias=0.5;
	var sig;
	sig = SinOsc.kr(freq).unipolar * modScale + modBias;
	sig = sig * EnvGen.kr(\adsr.kr(Env.adsr(0.1,0.1,0.8,0.1)), gate, doneAction:2);
	Out.kr(out, sig);
}).add;

Pdef(\demo, 
	Ppar([
		Pdef(\mod1, // need a Pdef around Pbind to control it
			Pmono( \modulator,
				\out, BusDef(\mod1, \control),
				\dur, 1,
			),
		),
		Pdef(\mod2, 
			Pmono( \modulator,
				\out, BusDef(\mod2, \control), 
				\dur, 1,
			),
		),
		Pdef(\melo, 
			Pbind(
				\instrument, \saw_help,
				\degree, Pseq((1..20).mirror,inf) % Pseq((3..15),inf),
				\dur, 1/4,
				\amp, 0.1,
			)
		)
	]),
).play;
);
::

To do modulation on any parameters of the synth and not only on the ones that
use In.kr to read a bus, SuperCollider allow you to map a bus to any synth
parameter using the link::Classes/Bus#.asMap:: method.

Busses are handled transparently by Param: if there is a bus mapped in a Pdef
or Ndef parameter, Param will reads and write on this bus. In this case, we do
not want to write on the bus, we want to select which bus to map. To do this,
we should use code::.asBusPopUpMenu:: instead of code::.asPopUpMenu::

To provide a list of values to choose from, code::.asBusPopUpMenu:: (and
code::.mapBusPopUpMenu::) expects a list of associations where the key is
the label displayed in the GUI and the value is the value put in the synth
parameter when its label is selected.

There is a special kind of spec named link::Classes/TagSpecDef:: with a
few lists already defined. Among them there is code::\BusDef:: which is the list of bus created
with link::Classes/BusDef:: and code::\BusDef_asMap:: which is the same list but
contains the bus map instead of the bus itself.

code::
(
WindowDef(\mywindow, {
	VLayout (
		PlayerWrapper(Pdef(\demo)).asView,
		
		// provide custom list
		Param(Pdef(\melo), \lpfr).asBusPopUpMenu([
			"no modulation" -> nil,
			"modulator 1" -> BusDef(\mod1).asMap,
			"modulator 2" -> BusDef(\mod2).asMap,
	   	]),

		// use existing list with TagSpecDef
		Param(Pdef(\melo), \lpfr).asBusPopUpMenu(TagSpecDef(\BusDef_asMap)), 

		// modulators params
		StaticText.new.string_("Mod 1").align_(\center),
		Param(Pdef(\mod1), \freq, \lofreq).asView,
		Param(Pdef(\mod1), \modScale, ControlSpec(0,4,\lin)).asView,
		StaticText.new.string_("Mod 2").align_(\center),
		Param(Pdef(\mod2), \freq, \lofreq).asView,
		Param(Pdef(\mod2), \modScale,  ControlSpec(0,4,\lin)).asView,
		nil
	)
}).front;
)
::


subsection:: modulate parameters with others synth

subsection:: Display value of the last tweaked parameter on GUI in one place

Each time a Param is tweaked in a GUI, it is put in link::Classes/Param#.lastTweaked:: and a changed message is sent.
You can use link::Classes/View#.followChange:: method to listen to this message and update the GUI.
This is useful for example when you don't want the value of each knob to clutter your GUI, so you display it in only one place.

code::
(
SynthDef(\saw_help, { arg out=0, amp=0.1, gate=1, pan=0, spread=0.8, freq=200,  doneAction=2;
	var sig, sig1, sig2, sig3;
	sig = LFSaw.ar(freq * [1.01,1,0.99]);
	sig = RLPF.ar(sig, \lpfr.kr(1.1) * freq, \rq.kr(0.5));
	sig = sig * EnvGen.ar(\adsr.kr(Env.adsr(0.01,0.1,0.8,0.1)),gate,doneAction:doneAction);
	sig = Splay.ar(sig, spread, amp, pan);
	Out.ar(out, sig);
}).add;

Pdef(\help, 
	Pbind(
		\instrument, \saw_help,
		\degree, Pseq([0],inf),
		\dur, 1,
		\amp, 0.1,
	)
).play;

WindowDef(\help, {
	var pg = Pdef(\help).asParamGroup;
	var curval = StaticText.new;
	var editcurval = TextField.new;

	curval.string = "---"; // default value

	// follow the Param.lastTweaked changes
	curval.followChange(Param, \lastTweaked, { arg view; 
		"there is a change! %: %".format(Param.lastTweaked.asLabel, Param.lastTweaked.stringGet).postln;

		// map the last changed Param to the StaticText and TextField
		curval.mapParamLabel(Param.lastTweaked);
		editcurval.mapParam(Param.lastTweaked);
	});

	VLayout (
		HLayout(
			curval,
			editcurval,
		),
		HLayout(
			*pg.collect({ arg param; // the star allow you to provide a list as a first argument of HLayout
				VLayout(
					param.asStaticTextLabel.align_(\center),
					param.asKnob.fixedSize_(40),
				)
			}) ++ [nil], // nil is used to add filling space
		),
		nil
	)
}).front;
)
::



subsection:: Have presets

There is more than one way to design a preset system, so no solution will fit all needs.

There is a built-in preset system in link::Classes/ParamGroup:: and link::Classes/ParamGroupDef::.

code::
ParamGroupDef(\group1, [
	Param(Pdef(\help), \lpfr),
	Param(Pdef(\help), \rq),
]);

ParamGroupDef(\group1).edit; 
ParamGroupDef(\group1).save(\preset1);
ParamGroupDef(\group1).load(\preset1);
::


You can use WindowDef(\PresetSelectorView) to display a PopUpMenu for selecting presets

code::
(
WindowDef(\help, { arg def, pg;
	VLayout (
		WindowDef(\PresetSelectorView).asView(pg),
		pg.asView,
	)
	
}).front(ParamGroupDef(\group1));
)
::

To save on disk, just write the presetCompileString in some file and execute it to load the presets

code::
ParamGroupDef(\group1).presetCompileString;
::

You can also use the link::Classes/Archive:: system (which is unreliable for me for unknown reasons)

code::
ParamGroupDef(\group1).saveArchive;
ParamGroupDef(\group1).loadArchive;
::

subsection:: Morph between presets

code::
(
ParamGroupDef(\group1, [
	Param(Pdef(\help), \lpfr),
	Param(Pdef(\help), \rq),
]);
)

// this create a morpher on a preset list named \preset0 to \preset7
~morpher = PresetListMorpher(ParamGroupDef(\group1), 8);
~morpher.normSet(0.5); // morph between presets at the center
~morpher.asSlider; // a morpher is a Param, you can use it in your GUI
::

You can use code::WindowDef(\PresetListMorpherView):: to have a basic GUI where you can store, load and morph between presets

code::
(
WindowDef(\help, { arg def, pg;
	VLayout (
		WindowDef(\PresetListMorpherView).asView(pg),
		pg.asView,
	)
}).front(ParamGroupDef(\group1));
)
::

subsection:: Defining macro parameter to control several parameters


subsection:: Choose the instrument in a PopUpMenu

code::
(
// first define a few synthdef and add them to the tag \mysynthlist
SynthDef(\saw_help, { arg out=0, gate=1, amp=0.1, pan=0, freq=200;
	var sig;
	sig = LFSaw.ar(freq);
	sig = RLPF.ar(sig, \lpfr.kr(1.1) * freq, \rq.kr(0.5));
	sig = sig * EnvGen.kr(\adsr.kr(Env.adsr(0.1,0.1,0.8,0.1)), gate, doneAction:2);
	sig = Pan2.ar(sig, pan, amp);
	Out.ar(out, sig);
}, metadata:(specs:(
	lpfr: ControlSpec(0.1,4,\lin, 0, 1)
))).add;
TagSpecDef(\mysynthlist).addUnique(\saw_help);

SynthDef(\pulse, { arg out=0, gate=1, amp=0.1, pan=0, freq=200;
	var sig;
	sig = LFPulse.ar(freq);
	sig = RLPF.ar(sig, \lpfr.kr(1.1) * freq, \rq.kr(0.5));
	sig = sig * EnvGen.kr(\adsr.kr(Env.adsr(0.1,0.1,0.8,0.1)), gate, doneAction:2);
	sig = Pan2.ar(sig, pan, amp);
	Out.ar(out, sig);
}, metadata:(specs:(
	lpfr: ControlSpec(0.1,4,\lin, 0, 1)
))).add;
TagSpecDef(\mysynthlist).addUnique(\pulse);

TagSpecDef(\mysynthlist).addUnique(\default); // also add default instrument


// define a pattern
Pdef(\help, 
	Pbind(
		// instrument will be defined by GUI
		\degree, Pwalk((0..20), Pseq((1..12)-2,inf) % Pseq((2..7),inf)),
		\dur, 1/2,
		\amp, 0.1,
	)
);
)

(
// define a GUI and display it to control instrument of the pattern
WindowDef(\help, { arg def;
	VLayout (
		PlayerWrapper(Pdef(\help)).asView,
		Param(Pdef(\help), \instrument, TagSpecDef(\mysynthlist)).asView,
		Param(Pdef(\help), \lpfr, ControlSpec(0.1,5,\lin)).asView,
		nil
	)
}).front;
)
::

subsection:: Foldable/Expandable panel

Every view have a link::Classes/View#.visible:: method that allow hidding it. You just have to add a button somewhere to control it's visible state and your collapse/expand view is made.

code::
(
WindowDef(\foldblock_help, { arg def;
		var layout;
		var blockview = View.new;
		blockview.layout = VLayout(
			Slider.new.orientation_(\horizontal),
			Slider.new.orientation_(\horizontal),
			Slider.new.orientation_(\horizontal),
			Slider.new.orientation_(\horizontal),
		);
		layout = VLayout(
			HLayout(
				Button.new.states_([
					["-"],
					["+"],
				]).action_({ arg me;
					if(me.value == 0) {
						blockview.visible = true;
					} {
						blockview.visible = false;
					}
				}).fixedWidth_(30),
				[StaticText.new.string_("Osc Block 1").background_(Color.grey), stretch:0],
			).spacing_(0),
			blockview,
			Button.new,
			nil
		);
		layout;

	
}).front;
);
::


subsection:: Changing a part of the GUI when some parameter change

The key is to use View as a placeholder. When some change is detected, remove all children of this view and recreate them.

This example display a PopUpMenu for changing the instrument, when instrument change is detected, it reload the list of sliders to match the parameters of the selected SynthDef

code::
(
Pdef(\help, 
	Pbind(
		// no instrument key to change it from GUI
		\degree, Pseq([0],inf),
		\dur, 1,
		\amp, 0.1,
	)
).play;
);

(
WindowDef(\help, { arg def, proxy;
	var paramView = View.new;
	// SynthDef_keys is the Spec for all the SynthDefs keys from Param GlobalLibrary
	var instrparam = Param(proxy, \instrument, TagSpecDef(\SynthDef_keys));

	// any view have a followChange method, when view is closed, the hook is automatically removed to avoid errors
	paramView.followChange(proxy, \set, { arg view, model, msg, pairs;
		[view, model, msg, pairs].postln;
		if(pairs.notNil and: {pairs.includes(\instrument)}) {
			paramView.removeAll;
			paramView.layout = proxy.asParamGroup.asView; // handy method to create view from a Pdef
		};
	});

	paramView.layout = proxy.asParamGroup.asView; // init

	VLayout (
		instrparam.asPopUpMenu,
		paramView;
	)
}).front(Pdef(\help));
);
::

subsection:: Write a GUI that can modify SynthDefs





section:: GUI Dialogs

subsection:: Creating an overlay menu

Context menus have been added relatively recently to Supercollider, but even
with them, you might want to use a borderless window instead. The benefit is
you can put any GUI component on it and make it as large as you want. I call
this kind of contextual borderless windows: Overlay menus.

code::
(
// first define the overlay menu window
WindowDef(\MyOverlayMenu, { arg def, model, view, x=0, y=0;
	var inview, layout;
	def.windowDo { arg win;
		// move window at the position of the click
		// x and y are relative to view top left corner
		var ab = view !? {view.absoluteBounds} ? Rect(0,0,600,600);
		win.bounds = Rect(x+ab.origin.x, Window.screenBounds.height - ab.top - y, 200,100);
		win.endFrontAction = { win.close };
	};
	inview = View.new;


	layout = VLayout (
		BasicButton.new.string_("hello").action_({
			// typically will act on model
			def.closeWindow; // handy to close window if we click a button
		}), 
		BasicButton.new.string_("hello2"),
		nil
	);
	inview.layout_(layout);
	
}).border_(false);
)

(
// then we can call it from any GUI
WindowDef(\help, { arg def;
	VLayout (
		BasicButton.new.string_("...").action_({ arg view;
			// we do not have x and y, it will use view top left corner
			// there is no model in this example so first argument is nil
			WindowDef(\MyOverlayMenu).front(nil, view)
		}),
		// show the overlay menu when right clicking on a view
		PlayerWrapper(Pdef(\help)).asView.mouseDownAction_({ arg view, x, y, modifiers, buttonNumber, clickCount;
			if(buttonNumber == 1) { // if right click
				WindowDef(\MyOverlayMenu).front(nil, view, x, y)
			} 
			
		}),
		nil,
	)
}).front;
)
::

subsection:: Choose a file

The first argument (here nil) is the default path, you can use it to browse automatically to a file when the dialog is opened (the last opened file for example).

code::
(
WindowDef(\filedialog_save).front(nil,{ arg path;
	"save to this file %".format(path).debug;
})
)

(
WindowDef(\filedialog).front(nil,{ arg path;
	"load from this file %".format(path).debug;
})
)
::

subsection:: Choose a directory



subsection:: Choose a sample

This file dialog only display audio files

code::
(
WindowDef(\filedialog_sample).front(nil,{ arg path;
	"load this sample %".format(path).debug;
})
)
::




subsection:: Choose a waveform sample




subsection:: Choose a SynthDef, Pdef, Timeline, etc (GlobalLibrary dialog)



This will open a browser window and when you click on an item, the callback is executed
First argument is default value, second is callback, third is list of tags to filter the browser list
the format of selected entry is code::[Class symbol, name -> object ]:: so you can get the object 
with code::val.last.value::

code::
(
WindowDef(\GlobalLibrary).front(nil, { arg val; val.debug("selected") }, [
	\Player, \AllTracks, \Timeline,
]);
)
::

You may prefer to have OK/Cancel button:

code::
(
WindowDef(\GlobalLibrary_select).front(nil, { arg val; val.debug("selected") }, [
	\Player, \AllTracks, \Timeline,
]);
)
::


Here is how GlobalLibrary_select is implemented:

code::
(
WindowDef(\GlobalLibrary_select_helper, { arg def, defaultValue, okHook, categories;
	var selected;
	VLayout (
		WindowDef(\GlobalLibrary).asView(nil, { arg val; 
			selected = val;
	   	}, categories),
		HLayout (
			BasicButton.new.string_("Cancel").action_({
				def.closeWindow;
			}),
			BasicButton.new.string_("Ok").action_({
				okHook.(selected);
				def.closeWindow;
			}),
		)
	)
}).front(nil, { arg val; val.debug("selected") })
)
::



subsection:: Choose a Param

FIXME: this WindowDef is not yet added in quark

code::
(
WindowDef(\ParamSelectDialog).front(nil, { arg param; 
	param.debug("selected param") 
});
)
::





section:: Sequencers

subsection:: Display a sequencer GUI for a Pbind

This Pbindef is a sequencer by itself. To control it by GUI, you just have to access to the list inside Pseq. This is done by using the special property code::\stepseq::.

This only works with Pbindef since we want to change invididual keys. You can convert any Pdef containing a Pbind into a Pbindef by using the method code::Pdef(\help).convertToPbindef::.

code::
(
Pbindef(\myseq,
	\instrument, \saw,
	\degree, Pseq([4,1,0,2],inf),
	\dur, 1/8,
	\amp, 0.1,
).play;
)

// quick GUI creation
Param(Pbindef(\myseq), \degree -> \stepseq, ControlSpec(0,12,\lin,1)).edit;

(
// build a real GUI
WindowDef(\help, { arg def;
	VLayout (
		PlayerWrapper(Pbindef(\myseq)),
		Param(Pbindef(\myseq), \degree -> \stepseq, ControlSpec(0,12,\lin,1)).asMultiSlider,
		Param(Pbindef(\myseq), \lpfr, ControlSpec(0.1,4,\lin)).asView
	)
}).front;
);
::

You can replace Pseq by PstepSeq, the main benefit is you can now have a cursor that show the progression in the sequence.

One nice thing to have in a sequencer is being able to have rests. You can simply sequence code::\amp:: but you may want to not launch a Synth node at all when there is a rest. This is done by having a key (code::\muter::) that output code::\rest:: if another key (code::\isNote::) is true. code::\rest:: is special and change the whole event into a rest. Then we can sequence code::\isNote:: to mute some steps.

code::
(
Pbindef(\myseq,
	\instrument, \saw,
	\degree, PstepSeq([4,1,0,2],inf),
	\isNote, PstepSeq(true!4,inf),
	\muter, Pif(Pkey(\isNote), 0,\rest),
	\dur, 1/8,
	\amp, 0.1,
).play;
)

(
// quick GUI creation using ParamGroup
ParamGroup([
	Param(Pbindef(\myseq), \degree -> \stepseq, ControlSpec(0,12,\lin,1)),
	Param(Pbindef(\myseq), \isNote -> \stepseq, ParamBoolSpec()), // notice the spec to have boolean values
]).edit
)
::

subsection:: Have a bank of sequences for a sequencer

Since you can point to a PstepSeq with a Param, it's only a matter of storing PstepSeqs somewhere, use them in pattern and in GUI.

code::
(
// first define a model which will store the score data, you can also use ProtoDef
~model = (
	bank: [
		PstepSeq(0!8),
		PstepSeq(0!8),
		PstepSeq(0!8),
		PstepSeq(0!8),
	],
	selector: PstepSeq(0!8,inf), // this pattern is the index in the list of sequences
	proxy: Pbindef(\help),
);

// define a pattern which will be our sequencer
Pbindef(\help,
	\instrument, \saw,
	// Pswitch select a pattern in a list according to another pattern
	\degree, Pswitch(~model.bank, ~model.selector), 
	\amp, 0.1,
);
)

// this Param point to the first sequence in our bank
// we use Message construct since there is no PstepSeq Param wrapper
Param( Message(~model.bank[0] ), \list).edit;

(
// here we build the full GUI
WindowDef(\help, { arg def, model;
	VLayout (
		PlayerWrapper(model.proxy),

		// for each sequence, we create a label and a MultiSliderView
		VLayout (* // there is a star because VLayout does not want a list but several arguments
			model.bank.collect { arg seq, idx;
				HLayout (
					StaticText.new.string_("seq" + idx).fixedWidth_(50),
					Param( Message(seq), \list, ControlSpec(0,12,\lin,1)).asMultiSlider
				)
			};
		),

		// selector sequencer GUI
		HLayout (
			StaticText.new.string_("selector").fixedWidth_(50),
			Param( Message(model.selector), \list, ControlSpec(0,model.bank.size-1,\lin,1)).asMultiSlider,
		),

		// control the dur of the pattern
		Param(Pbindef(\help), \dur, ControlSpec(0.01,1,\exp)),
	)
}).front(~model);
)



::



subsection:: Have a bank of sequences for several sequencers


subsection:: Transform automatically a Pbindef into a sequencer

(
// each Pseq or PstepSeq will become a graphical sequencer
Pbindef(\myseq,
	\instrument, \saw,
	\degree, Pseq(0!8,inf),
	\lpfr, PstepSeq(1!8,inf),
	\rq, Pseq(0.1!8,inf),
	\muteseq, Pseq(false!8,inf),
	\muter, Pif(Pkey(\muteseq), \rest, 0),
	\dur, 1/8,
	\amp, 0.1,
).play;

// add some specs
SynthDesc(\saw).addSpec(\lpfr,ControlSpec(0.1,4,\lin) );
Spec.add(\muteseq, ParamBoolSpec(reverse:true));
Spec.add(\degree, ControlSpec(0,14,\lin,1));
)

(
WindowDef(\PbindefSeq, { arg def, target;
	VLayout (
		PlayerWrapper(target),
		VLayout (*
			// we retrieve each [key,val] of the Pbindef
			target.source.pairs.clump(2).collect({ arg pair;
				pair.debug("pair");
				if(pair[1].source.isKindOf(ListPattern)) {
					// if it's a ListPattern, build a param with special key \stepseq to point to the list
					var param = Param(target, pair[0] -> \stepseq);
					HLayout (
						param.asStaticTextLabel.fixedWidth_(60),
						param.asMultiSlider.attachContextMenu, // add right-click menu allowing you to change number of steps
					)
				}
			}).select(_.notNil)
		)
	)
	
}).front(Pdef(\myseq));
);

subsection:: Control a sequencer with MIDI controller

Once you have your Param pointing to a list, you can assign any slot of this list to a MIDI controller knob or button

code::
(
// 8 knobs with cc number from 16 to 23
(16..23).do { arg ccnum, idx;
	MIDIdef.cc(\knob+++idx, { arg val, channel, deviceId;
		[ ccnum, val, channel, deviceId ].debug("cc");
		Param(Pbindef(\help), \lpfr -> \stepseq -> idx).normSet(val/127);
	}, ccnum); 
};
)
::

With Modality Toolkit, there is a extension method that allow you to quickly map a group of knobs or other elements

code::
// MKtl(\icon)[\kn] is a MKtlElementGroup containing 9 knobs
MKtl(\icon)[\kn].mapParam( Param( Pbindef(\help), \lpfr -> \stepseq ) );

(
// arbitrary param group mapping
MKtl(\icon)[\kn].mapParam([
	Param( Pdef(\bete), \degree -> \stepseq -> 2 ), // assign first knob to step 2 of the degree Pseq
	Param( Pdef(\bete), \rq -> \stepseq -> 1 ),
])
)
::


section:: Timelines

subsection:: Visualize a Pbind score

You can use TimelineEventList.newFrom to create a TimelineEventList from a Pattern. Then assign this list to a timeline, and you can visualize it.

code::
(
// assign a new TimelineEventList to a NoteTimeline
NoteTimeline(\help).eventList = TimelineEventList.newFrom(
	Pbind(
		\instrument, \default,
		\degree, Pseq((0..9),inf) % Pseq((3..16),inf),
		\dur, 1/8,
		\amp, 0.1,
	),
	64, // how many event to record
);
)

NoteTimeline(\help).edit; // now display it
::

Custom GUI

code::
(
WindowDef(\help, { arg def;
	VLayout (
		NoteTimeline(\help).asPreview, // minimal view
		NoteTimeline(\help).asView, // full editor
	)
	
}).front;
);
::

subsection:: Record your piano controller

Use NoteTimeline for recording notes from a piano controller.
On the GUI, there is a record button, there is also in the code::...:: menu a popup menu that allow to choose which controller in connected to this timeline.

code::
NoteTimeline(\help).edit; // default SynthDef

// use custom SynthDef and patterns
Pdef(\mysynth, Pbind(\instrument, \saw)); 
NoteTimeline(\help, Pdef(\mysynth)).edit;
::


subsection:: Record your drumpad controller

Instead of taking notes from a Pdef like NoteTimeline, we have an array of pattern, each one represent a particular drum, so when we hit a drumpad, the corresponding drum pattern is played.gtg
Use KitTimeline for recording notes from a drumpad controller.
On the GUI, there is a record button, there is also in the code::...:: menu a popup menu that allow to choose which controller in connected to this timeline.



subsection:: Record your launchpad controller

subsection:: Record a parameter 


subsection: add a preview of a timeline in a GUI

code::
(
WindowDef(\help, { arg def;
	VLayout (
		NoteTimeline(\help).asPreview, // minimal view
	)
	
}).front;
);
::


subsection:: Import a MIDI file in a timeline

You will need the SimpleMIDIFile from wslib quark.
The idea is to convert the midi file to a pattern then convert the pattern to a TimelineEventList.

code::
// here is how to play a pattern from a MIDI file
// note: it's not required to play the pattern to convert it, it's just for demo purpose
// no need to set tempo either since event time is in beats
m = SimpleMIDIFile.read( "~/Téléchargements/Super Mario Bros 2 - Mario Dreams.mid" ); 
(
	TempoClock.default.tempo = m.tempo/60; 
	Pdef(\midipat, 
		Pbind(
			\instrument, \default,
			[\midinote, \dur, \sustain, \amp], Prout({ arg ev;
				var timescale = 1/480/2;
				var prevev;
				m.noteSustainEvents.collect({ arg item, idx;
					// [track, absTime, \noteOn, channel, note, velo, dur, upVelo]
					// compute relative time and scale
					if(idx == 0) {
						prevev = [item[4], item[1], item[6] * timescale, item[5]/127]
					} {
						prevev[1] = item[1] - prevev[1] * timescale;
						ev = prevev.yield;
						prevev = [item[4], item[1], item[6] * timescale, item[5]/127];
					};
				});
				prevev[1] = prevev[2];
				ev = prevev.yield; // last event
			}),
			\midinote, Pkey(\midinote) - 12, // one octave lower
			\amp, 0.1,
		)
	).play
)


/// now that we have our pattern, let's import it
NoteTimeline(\help).eventList = TimelineEventList.newFrom( Pdef(\midipat),4000 ); // 4000 is the max number of event to record

NoteTimeline(\help).edit; // now visualize
::







section:: Controllers (MIDI, OSC, ...)

I talk only about MIDI controllers, but OSC controllers can connect to Param the same way using link::Classes/OSCdef:: (well anything really).




subsection:: Control a parameter 

Like the GUI components, all the controllers data is sent in normalized form (from 0 to 1). In MIDI this is from 0 to 127 but you just have to divide by 127 to normalize it.
Param objects have two convenient methods: normSet and normGet which allow you to work with normalized values and let the Spec do the conversion for you.

The standard way to interact with controllers is using MIDIdef:

code::
(
SynthDef(\saw_help, { arg out=0, amp=0.1, gate=1, pan=0, spread=0.8, freq=200,  doneAction=2;
	var sig, sig1, sig2, sig3;
	sig = LFSaw.ar(freq * [1.01,1,0.99]);
	sig = RLPF.ar(sig, \lpfr.kr(1.1) * freq, \rq.kr(0.5));
	sig = sig * EnvGen.ar(\adsr.kr(Env.adsr(0.01,0.1,0.8,0.1)),gate,doneAction:doneAction);
	sig = Splay.ar(sig, spread, amp, pan);
	Out.ar(out, sig);
}, metadata:(specs:(
	lpfr: ControlSpec(0.5,4,\lin, 0, 1)
))).add;

Pdef(\help, 
	Pbind(
		\instrument, \saw_help,
		\degree, Pseq([0],inf),
		\dur, 1,
		\amp, 0.1,
	)
).play;

MIDIdef.cc(\knob1, { arg val, channel, deviceId;
	[ val, channel, deviceId ].debug;
	Param(Pdef(\help), \lpfr).normSet(val/127); // normSet automatically map from 0..1 according to the spec of the param
}, 16); // change your midi cc number for your first knob
)
::

Modality-toolkit quark can also be used with Param:

code::
k = MKtl('icon', "icon-icontrols"); // use modality-toolkit to access the icon-icontrols MIDI controller
k[\kn][0].mapParam( Param(Pdef(\help), \lpfr) ); // map the knob 0 to a Param
::





subsection:: Control a parameter with a bus

When controlling a parameter in a pattern, the value is kept constant for the duration of each note. To have smooth control, you have to map a bus.
Param handle this transparently. The only thing to do is to call code::param.setBusMode(true)::

code::
(
SynthDef(\saw_help, { arg out=0, amp=0.1, gate=1, pan=0, spread=0.8, freq=200,  doneAction=2;
	var sig, sig1, sig2, sig3;
	sig = LFSaw.ar(freq * [1.01,1,0.99]);
	sig = RLPF.ar(sig, \lpfr.kr(1.1) * freq, \rq.kr(0.5));
	sig = sig * EnvGen.ar(\adsr.kr(Env.adsr(0.01,0.1,0.8,0.1)),gate,doneAction:doneAction);
	sig = Splay.ar(sig, spread, amp, pan);
	Out.ar(out, sig);
}, metadata:(specs:(
	lpfr: ControlSpec(0.5,4,\lin, 0, 1)
))).add;

Pdef(\help, 
	Pbind(
		\instrument, \saw_help,
		\degree, Pseq([0],inf),
		\dur, 1,
		\amp, 0.1,
	)
).play;

Param(Pdef(\help), \lpfr).setBusMode(true); // now the Pdef \lpfr parameter contains a bus map and change is smooth
Param(Pdef(\help), \lpfr).get.postln; // this post the value of the bus

MIDIdef.cc(\knob1, { arg val, channel, deviceId;
	[ val, channel, deviceId ].debug;
	Param(Pdef(\help), \lpfr).normSet(val/127); // normSet automatically map from 0..1 according to the spec of the param
}, 16); // change your midi cc number for your first knob
)
::


subsection:: Control a player with a MIDI button

There is nothing special, except we use a PlayerWrapper because Pdef(\help).stop stops immediately without following quant, PlayerWrapper make sure all players behave the same.

code::
MIDIdef.noteOn(\track1, { arg velocity, noteNum, channel, deviceId;
	[ velocity, noteNum, channel, deviceId ].debug;
	PlayerWrapper(Pdef(\help)).togglePlay; // togglePlay method is added by PlayerWrapper
}, noteNum:8);
::


Or you can stop the pattern when you release the button:

code::
(
MIDIdef.noteOn(\track1, { arg velocity, noteNum, channel, deviceId;
	[ velocity, noteNum, channel, deviceId ].debug;
	PlayerWrapper(Pdef(\help)).play
}, noteNum:8);
MIDIdef.noteOff(\track1_off, { arg velocity, noteNum, channel, deviceId;
	[ velocity, noteNum, channel, deviceId ].debug;
	PlayerWrapper(Pdef(\help)).stop
}, noteNum:8);
)
::


Use .playNow to ignore quant:

code::
(
MIDIdef.noteOn(\track1, { arg velocity, noteNum, channel, deviceId;
	[ velocity, noteNum, channel, deviceId ].debug;
	PlayerWrapper(Pdef(\help)).playNow
}, noteNum:8);
MIDIdef.noteOff(\track1_off, { arg velocity, noteNum, channel, deviceId;
	[ velocity, noteNum, channel, deviceId ].debug;
	PlayerWrapper(Pdef(\help)).stopNow
}, noteNum:8);
)
::

If you use Modality quark, there is an extension method mapPlayer that can map a button for you.
code::

MKtl(\apc40).elAt(\bt, \clip, 0,0,\on).mapPlayer(PlayerWrapper(Pdef(\help))); // when you push the button, the pattern start playing or stop if already playing

MKtl(\apc40).elAt(\bt, \clip, 0,0).mapPlayer(PlayerWrapper(Pdef(\help))); // this map \on and \off actions so when you release the button, the pattern stop
::

subsection:: Control a player with a MIDI knob

The trick is to build a Param pointing to the property \isPlaying of the PlayerWrapper. When the knob value > 0.5, the Pdef is played, when < 0.5 it is stopped.

code::
MIDIdef.cc(\knob1, { arg val ...args;
	Param( Message(PlayerWrapper(Pdef(\help))), \isPlaying, ParamBoolSpec() ).normSet(val/127);
}, ccNum:8);
::

subsection:: Learn MIDI ccnum to control any Param

Note that with default editors like PdefEditor, you can right-click on a Param label and you will get a window allowing you to map this Param to a learned MIDI knob.

This is how it is done under the hood:

code::
(
// define a pattern
Pdef(\help, 
	Pbind(
		\instrument, \default,
		\dur, 1,
		\amp, 0.1,
	)
).play;
);

(
// the first knob you will turn will be assigned to this Param
MIDIFunc.cc({ arg val ...args;
	Param(Pdef(\help), \freq).normSet(val/127)
}).learn; // learn!
)

(
// you can also use MIDIdef to avoid mapping the same knob to several Param
MIDIdef.cc(\knob1, { arg val ...args;
	Param(Pdef(\help), \freq).normSet(val/127)
}).fix.learn; // fix it so CmdPeriod will not remove it
)
::


Param(Pdef(\help), \freq).setBusMode(true); // easy bus mode

subsection:: Control a PopUpMenu with a controller

note::
You will have to clear the Pbindef if you executed the previous recipes because sequencer data and all other keys will remain
::

code::
Pbindef(\help).clear;
Pbindef(\help).envir.clear;
::

Now let's write our three parts: the model, the GUI and the MIDI controller

code::
(
// define a pattern to play
Pbindef(\help,
	\degree, Pseq([3,1,2,0],inf),
).play;

// define a spec, we will select the instrument from this list
TagSpecDef(\instrlist, [\default, \saw]);
~param = Param(Pbindef(\help), \instrument, TagSpecDef(\instrlist));

// define a GUI
WindowDef(\help, { arg def;
	~param.asView; // display the list as a PopUpMenu
}).frontTop;
);

(
MIDIFunc.cc({ arg val ...args;
   	// setting the Param will automatically select the corresponding instrument in the list and update the PopUpMenu
	~param.normSet(val/127);
}).learn; // learn!
)
::

subsection:: Select controller by a PopUpMenu

code::

(
// use MIDIdef.trace to find the ccnums

// define two controllers blocks

ControllerDef(\icon_knobs, { arg def, params;
	// map 4 knobs with cc number given in the list
	// note that you can also use OSC protocol here, or anything you want
	// note that .permanent is false so CmdPeriod will remove the MIDIdef
	[16,17,21,22].collect({ arg ccnum, idx;
		if(params[idx].notNil) {
			MIDIdef.cc("icon_knob%".format(idx).asSymbol, { arg val, channel, deviceId;
				[ val, channel, deviceId ].debug;
				params[idx].normSet(val/127); 
			}, ccnum);
		}
	})
}, \knobline);

ControllerDef(\icon_sliders, { arg def, params;
	[0,1,2,3].collect({ arg chan, idx;
		if(params[idx].notNil) {
			MIDIdef.cc("knobline2_knob%".format(idx).asSymbol, { arg val, channel, deviceId;
				[ val, channel, deviceId ].debug;
				params[idx].normSet(val/127); 
			}, 13, chan); // my controller is ugly and use chan to differentiate sliders
		}
	})
}, \knobline); // tag this ControllerDef

);



(
// this gui display a list of Param and allow to choose a MIDI controller to control them
WindowDef(\knobline, { arg def, pgroup;
	// param need a model to control, we create a small one
	var model = ProtoClass((
		controller_: { arg self, con;
			con.debug("con");
			self[\controller] = con;
			con.startControl(pgroup)
		},
	));
	VLayout (
		HLayout(
			StaticText.new.string_("controller:"),
			Param(
				Message(model),
				\controller, 
				ControllerDef.getTagSpec(\knobline), // retrieve the list of controllers by tag
			).asPopUpMenu, 
		),
		pgroup.asView
	)
});
)


(
// open the window with a group of params
WindowDef(\knobline).front(ParamGroup([
	Param(Pdef(\help), \lpfr),
	Param(Pdef(\help), \rq),
]));
)

Pdef(\help).play; // play the pattern, you can also add a button in the WindowDef

(
// you can create another window on the same template
WindowDef(\knobline2, WindowDef(\knobline)).front(ParamGroup([
	Param(Pdef(\help2), \lpfr),
	Param(Pdef(\help2), \rq),
]));
)

(
// or show both in the same window
WindowDef(\allknoblines, {
	VLayout (
		WindowDef(\knobline).asView(ParamGroup([
			Param(Pdef(\help), \lpfr),
			Param(Pdef(\help), \rq),
		])),
		WindowDef(\knobline).asView(ParamGroup([
			Param(Pdef(\help2), \lpfr),
			Param(Pdef(\help2), \rq),
		])),
		nil
	)
}).front;
)
::

subsection:: Generate a GUI for a MIDI synth

code::
//
::

section:: Internal





section:: Advanced

subsection:: write a Fx Manager

subsection:: write a mixer SynthDef with a GUI

subsection:: write a player grid view

subsection:: write a modulator matrix

subsection:: write a modulator table

subsection:: writing timeline views basics

